




\subsection{Algorithm to solve Disjoint Path problem and the proof of Theorem~\ref{theorem_disjoint_path}}

To construct an algorithm satisfying Theorem~\ref{theorem_disjoint_path}, we define the function $\mathsf{Cal}$. DAG $G=(V, E)$のnice DAGパス分解を$X=(X_1, X_2, \dots , X_s)$とする．ある$i$ $(i=1, 2, \dots , s)$に対し，頂点集合$A^1_i, A^2_i, \dots , A^k_i, B_i \subseteq V$が$A^1_i \cup A^2_i \cup \dots \cup A^k_i \cup B_i = X_i$を満たし，さらに$A^1_i, A^2_i, \dots ,A^k_i, B_i$のうち任意の2つの頂点集合は共通部分集合を持たないとする．$G_i$を頂点集合$X_1 \cup X_2 \cup,  \dots \cup X_i$によって誘導される$G$の部分グラフとし，$\mathscr{A}_i=(A^1_i, A^2_i, \dots ,A^k_i)$とする．

$\mathsf{Cal}$は各$G_i$に対し，各$A_m\ (m=1, 2, \dots, k)$がそれぞれ各$s_m$を始点とする点素パスの一部となれるかを考え，このような点素パスの組合せのうちパスの合計長が最小の組み合わせを求める．これを全ての$A_1, A_2, \dots, A_k, B_i$の組合せについて計算することで，$G_i$での合計長最小の点素パスの組合せを得る．全ての$i$について上記の計算を行うことで最終的に入力グラフ$G$の合計長最小の点素パスの組合せを得る．$\mathsf{Cal}$を以下のように定める．

\begin{equation}\label{def_cal}
    \mathsf{Cal}(i, \mathscr{A}_i, B_i) = \min \sum_{m=1}^k (|P^m_i| - 1).
\end{equation}

ただし，頂点集合$P^m_i (i\leq m \leq k)$は$P^m_i \subseteq X_1 \cup X_2 \cup,  \dots \cup X_i$を満たし，それぞれ$s_m$を始点とする点素なパスを構成し，$m' \neq m$として$A^m_i \subseteq P^m_i, A^{m'}_i \cap P^m_i = \varnothing, B_i \cap P^m_i = \varnothing$を満たす．このとき$\mathsf{Cal}$は$G_i$の各$s_m$を始点とする$k$個の点素なパスの合計長の最小値を計算する関数である．



以下で$\mathsf{Cal}$の計算式を与える．各$X_i$がintroduceかforgetかで場合分けをして計算する．ただし頂点対の始点と終点の集合をそれぞれ$S=\{s_1, s_2, \dots, s_k\}, T=\{t_1, t_2, \dots, t_k\}$とする．
%
\begin{align}
    \intertext{$\bullet$ $X_i$が$v \in S$をintroduceしているとき ($v = s_m$とする)}
    &\mathsf{Cal}(i, \mathscr{A}_i, B_i) = \label{cal0}
    \begin{cases}
        0                                                   &(A^m_i = \{v\}) \\
        \infty                                              &(otherwise)
    \end{cases}.
    \intertext{$\bullet$ $X_i$が$v \in T$をintroduceしているとき ($v = t_m$とする)}
    &\mathsf{Cal}(i, \mathscr{A}_i, B_i) = \label{cal1}
    \begin{cases}
        \mathsf{Cal}(i-1, \mathscr{A}^m_i, B_i)+1                    &(v \in A^m_i \text{かつ，ある} w \in \mathsf{pred}(v) \cap A^m_i\\ &\text{が存在し，} \mathsf{suc}(w) \cap A^m_i = \{v\}) \\
        \infty                                              &(otherwise)
    \end{cases}.
    \intertext{$\bullet$ $X_i$が$v \in V \backslash (S \cup T)$をintroduceしているとき}
    &\mathsf{Cal}(i, \mathscr{A}_i, B_i) = \label{cal2}
    \begin{cases}
        \mathsf{Cal}(i-1, \mathscr{A}^m_i, B_i)+1                    &(v \in A^m_i \text{かつ，ある} w \in \mathsf{pred}(v) \cap A^m_i\\ &\text{が存在し，} \mathsf{suc}(w) \cap A^m_i = \{v\}) \\
        \mathsf{Cal}(i-1, \mathscr{A}^m_i, B_i \backslash \{v\})     &(v \in B_i) \\
        \infty                                              &(otherwise)
    \end{cases}.
    \intertext{$\bullet$ $X_i$が$v \in V$をforgetしているとき}
    &\mathsf{Cal}(i, \mathscr{A}_i, B_i) = \label{cal3}
    \min \{\min_{1 \leq m \leq k} \{\mathsf{Cal}(i-1, \mathscr{\overline{A}}^m_i, B_i)\}, \mathsf{Cal}(i-1, \mathscr{A}^m_i, B_i \cup \{v\})\}.
\end{align}

ただし，$v \in V$に対し$\mathscr{A}^m_i, \mathscr{\overline{A}}^m_i$を以下のように定める．
%
\begin{align*}
    \mathscr{A}^m_i &= (A^1_i, A^2_i,  \dots, A^m_i \backslash \{v\}, \dots, A^k_i). \\
    \mathscr{\overline{A}}^m_i &= (A^1_i, A^2_i,  \dots, A^m_i \cup \{v\}, \dots, A^k_i).
\end{align*}


$\mathsf{Cal}$を用いて，DAG $G$のnice DAGパス分解$P$が与えられたときに，$G$のDisjoint Path Problemの解を出力するアルゴリズム$\mathsf{Compute}(P）$を示す．


\begin{enumerate}
    \item Preprocessing: 入力グラフが単一頂点$s_1=t_1$からなる場合，0を出力する．そうでない場合，各頂点$t \in T$に入る枝をすべて削除する．こうしてできるグラフを便宜上新たに$G$とする．
    \item First Step: $\mathsf{Cal}(0, (\varnothing, \varnothing, \dots, \varnothing), \varnothing) = 0$とする．
    \item Exection Step: $P$の各$X_i$ $(i=1, 2, \dots, s)$に対し，$\mathscr{A}_i, B_i$全ての組合せについて順に$\mathsf{Cal}(i, \mathscr{A}_i, B_i)$を計算する．
    \item Final Step: $i = s$ならば，$\mathsf{Cal}(s, (\varnothing, \varnothing, \dots, \varnothing), \varnothing)$を出力する．
\end{enumerate}

To demonstrate Theorem~\ref{theorem_disjoint_path}, it is sufficient to prove the following two Lemmas.

\begin{lemma}\label{dpp}
    $\mathsf{Compute}$は$G$のDisjoint Path Problemの解を出力する．
\end{lemma}

\begin{proof}
    入力グラフ$G$が単一頂点$s_1=t_1$からなる場合，$\mathsf{Compute}$のPreprocessingの処理により0を出力する．これは明らかに$G$のDisjoint Pathになっている．以下では$G$が単一頂点から成らない場合を考える．あるバッグ$X_i$が$v \in V$をintroduceするとき，$v$は$A^1_i, A^2_i,  \dots, A^k_i, B_i$のいずれかにのみ含まれるため，これを1から$i$まで考えることにより各パス$P^m_i$は互いに共通の頂点を持たない点素なパスであることが示される．また，ある始点$s_m \in S$がintroduceされたバッグを$X_{i_s}$とすると，$X_{i'}$ $(i' < i_s)$でintroduceされた頂点はパス$P^m_{i_s}$に含まれることはない．なぜならば，$X_{i'}$で頂点$u$がintroduceされ，かつ$A^m_{i'} = \{u\}$であるとすると，$\mathsf{pred}(u) \cap A^m_{i'} = \varnothing$であり，式\ref{cal2}の条件より$\mathsf{Cal}$の値は$\infty$となるからである．さらに，ある終点$t_m \in S$がintroduceされたバッグを$X_{i_t}$とすると，$X_{i'}$ $(i_t < i')$でintroduceされる頂点はパス$P^m_{i'}$に含まれることはない．なぜならば，$X_j$ $(i_t < j)$で頂点$w$がintroduceされ，かつ$\mathsf{Compute}$のPreprocessingを行う前の入力グラフにおいて$w \in \mathsf{suc}(t_m)$であるとする．ここで$w \in A^m_j$であるとすると，DAGパス分解のルール2より$t_m \in A^m_j$がいえるが，もし$\mathsf{pred}(w) \cap (A^m_j \backslash \{t_m\}) = \varnothing$ならば，Preprocessingの処理により$\mathsf{pred}(w) \cap A^m_j = \varnothing$であるため，式\ref{cal2}の条件より$\mathsf{Cal}$の値は$\infty$となる．一方，$\mathsf{pred}(w) \cap (A^m_j \backslash \{t_m\}) \neq \varnothing$ならば，ある頂点$p \in \mathsf{pred}(w) \cap A^m_j$ $(p \neq t_m)$が存在し，式\ref{cal2}の条件より，$p$のある後続頂点$q \in A^m_j$ $(p \in \mathsf{pred}(q) \cap (A^m_j \backslash \{w\}) \text{かつ} \mathsf{suc}(p) \cap (A^m_j \backslash \{w\}) = \{q\})$が存在する．Preprocessingの処理によって枝$(t_m, w)$が除かれることに注意すると$\{q, w\} \subseteq \mathsf{suc}(p) \cap A^m_j$が成り立つため，$w$のintroduceにおいて式\ref{cal2}の条件より$\mathsf{Cal}$の値は$\infty$となる．これ以降のバッグ$X_l$ $(j < l)$でintroduceされた頂点$w'$が$A^m_l$に含まれた場合，枝$(w, w')$が存在すれば式\ref{cal2}の条件より$\mathsf{Cal}$の値は$\infty$となり，枝$(w, w')$が存在しなければ上記と同様の議論により$\mathsf{Cal}$の値は$\infty$となる．以上より$X_{i_t}$以降でintroduceされた頂点はパス$P^m_{i_t}$に追加されることはない．\\
    以上の議論に注意すると，Lemma~\ref{dpp}の証明では，各$i$ $(i_s \leq i \leq i_t)$に対し，ある$m$ $(1 \leq m \leq k)$について$\mathsf{Cal}(i, \mathscr{A}_i, B_i)$が$\mathsf{Cal}$の定義\ref{def_cal}を満たすことを示せば十分．これを$i$に関する数学的帰納法で示す．\\
    $i=i_s$のとき，式\ref{cal0}より$A^m_{i_s} = \{s_m\}$の場合は0であり,これは$s_m$のみからなるパス$P^m_{i_s}$の長さが0であることを表す．これは明らかに定義\ref{def_cal}を満たす．$A^m_{i_s} \neq \{s_m\}$の場合は$\infty$であるが，これは$s_m$を始点とするパスが構成されないことを表すため，同様に定義\ref{def_cal}を満たす．\\
    ある$i$ $(i_s \leq i < i_t)$において，$\mathsf{Cal}(i, \mathscr{A}_i, B_i)$が定義\ref{def_cal}を満たすと仮定する．以下で$X_{i+1}$が$v \in V$をintroduceするかforgetするかで場合分けを行う．
    \begin{itemize}
        \item $X_{i+1}$が$v \in V$をintroduceする場合 \\
        まず$v \in A^m_{i+1}$の場合を考える．$A^m_{i+1}$に含まれ，かつ$v$の直前にintroduceされた頂点を$u$とする．DAGパス分解のルール2より，$u, v$の間には枝$(u, v)$が存在するか，$(u, v)$は存在せず$u$以外の頂点$u'$ $(u' \in A^m_{i+1})$との間の枝$(u', v)$が存在するか，$A^m_{i+1}$に含まれるどの頂点との間にも枝が存在しないかのいずれかである．枝$(u, v)$が存在する場合，式\ref{cal2}より$\mathsf{Cal}(i+1, \mathscr{A}_{i+1}, B_{i+1}) = \mathsf{Cal}(i, \mathscr{A}^m_{i+1}, B_{i+1})+1$となる．DAGパス分解のルール2より$u$はパスの端点であることに注意すると，仮定より$\mathsf{Cal}(i, \mathscr{A}^m_{i+1}, B_{i+1})$は$m$番目のパスが$s_m$から$u$までのパスであるときの全パスの合計長の最小値を表している．したがって$m$番目のパスの端点$u$に$v$を加えることで合計長を1だけ大きくしており，$\mathsf{Cal}(i+1, \mathscr{A}_{i+1}, B_{i+1})$は明らかに全パスの合計長の最小値を表す．よって定義\ref{def_cal}を満たす．枝$(u, v)$が存在せず$u$以外の頂点$u'$ $(u' \in A^m_{i+1})$との間の枝$(u', v)$が存在する場合，上記の$t_m$と同様の議論により，ある頂点$v' \in A^m_{i+1}$ $(v' \neq v)$が存在し，$\{v, v'\} \subseteq \mathsf{suc}(u') \cap A^m_{i+1}$が成り立つ．したがって式\ref{cal2}の条件より$\mathsf{Cal}$の値は$\infty$となる．これは$A^m_{i+1}$において枝分かれ$\{(u', v),\ (u', v')\}$が存在し，これらを含むようなパスが存在しないことを表す．したがって定義\ref{def_cal}を満たす．$v$と$A^m_{i+1}$に含まれるどの頂点との間にも枝が存在しない場合，式\ref{cal2}の条件より$\mathsf{Cal}$の値は$\infty$となる．これは$A^m_{i+1}$に含まれる頂点を使って$s_m$と$v$をつなぐパスを構成することができないことを表す．したがって定義\ref{def_cal}を満たす．\\
        $v \in B_{i+1}$の場合，$v \notin A^m_{i+1}$より，$P^m_{i+1}$は$s_m$から$u$までのパスであり，仮定よりこのときのパスの合計長の最小値は$\mathsf{Cal}(i, \mathscr{A}^m_{i+1}, B_{i+1} \backslash \{v\})$で表される．したがって式\ref{cal2}より$\mathsf{Cal}(i+1, \mathscr{A}^m_{i+1}, B_{i+1})$は$v$がどのパスにも含まれないときのパスの合計長の最小値を表すため，定義\ref{def_cal}を満たす．\\
        %
        \item $X_{i+1}$が$v \in V$をforgetする場合 \\
        $G_{i+1} = G_i$より，$G_{i+1}$と$G_i$でのパスの合計長の最小値は等しい．したがって$v$が$P^1_i, \dots , P^k_i$のいずれかのパスに含まれていた場合と，いずれにも含まれていない，すなわち$B_i$に含まれている場合とを考え，より値の小さいものを$i+1$における$\mathsf{Cal}$の値とすることができる．仮定よりそれぞれ$\mathsf{Cal}(i, \mathscr{\overline{A}}^m_{i+1}, B_{i+1}),\mathsf{Cal}(i, \mathscr{A}^m_{i+1}, B_{i+1} \cup \{v\})$と表すことができるため，式\ref{cal3}は定義\ref{def_cal}を表すようなパスの合計長の最小値を出力する．
    \end{itemize}
    以上より，$i = i+1$でも定義\ref{def_cal}が成立．数学的帰納法によりLemma~\ref{dpp}が証明された．
\end{proof}



\begin{lemma}
    DAG $G$の頂点数が$n$であるとする．このとき，幅が$w$である$G$のDAGパス分解$P$が与えられたとき，$\mathsf{Compute}(P)$は$O((k+1)^w(w^2+k)n+n^2)$の計算時間で結果を出力する．
\end{lemma}

\begin{proof}
    Preprocessingにおいて，$G$が単一頂点からなるかどうかは$O(1)$で判定できる．また各$t \in T$に入るすべての枝の削除は$O(n^2)$かかる．First Step, Final Stepは各々O(1)で計算できる．以下でExection Stepでの計算量を考える．各$X_i$に対し，$|X_i| \leq w+1$に注意すると，$A^1_i, A^2_i, \dots, A^k_i, B_i$の組合せは高々$(k+1)^{w+1}$通り存在する．またProposition~\ref{number_of_bag}より$0 \leq i \leq 2|V|+1$である．さらに$\mathsf{pred}(v), \mathsf{suc}(v)$の計算量がそれぞれ高々$O(w)$であることに注意すると，$\mathsf{Cal}(i, \mathscr{A}_i, B_i)$の計算量は，$X_i$がintroduceならば$O(w^2)$であり，forgetならば$O(k)$である．以上より，$\mathsf{Compute}$の計算量は$O((k+1)^w(w^2+k)n+n^2)$である．
\end{proof}

また上記のアルゴリズムに変更を加えることで，辺素パス問題など類似の問題を解くアルゴリズムを構築することができる．














\subsection{Algorithm to solve DST problem and the proof of Theorem~\ref{theorem_DST}}


To construct an algorithm satisfying Theorem~\ref{theorem_DST}, we define the function $\mathsf{ST}$. DAG $G=(V, E)$のnice DAGパス分解を$P=(X_1, X_2, \dots , X_s)$とする．ある$i$ $(i=1, 2, \dots , s)$に対し，頂点集合$A_i, B_i \subseteq V$が$A_i \cup B_i = X_i, A_i \cap B_i = \varnothing$を満たすとする．$G_i$を頂点集合$X_1 \cup X_2 \cup,  \dots \cup X_i$によって誘導される$G$の部分グラフとする．

$\mathsf{ST}$は各$G_i$に対し，$R\cap V[G_i]$をすべて含む有向シュタイナー木のうち$A_i$を全て含み，$B_i$を全て含まず，かつサイズが最小の有向シュタイナー木を求める．これを全ての$A_i, B_i$の組合せについて計算することで，$G_i$での最小有向シュタイナー木を得る．全ての$i$について上記の計算を行うことで最終的に入力グラフ$G$の最小有向シュタイナー木を得る．以下では$d(e)$を枝$e$の重みとする．関数$\mathsf{ST}$を以下のように定める．

\begin{equation}
    \mathsf{ST}(i; A_i, B_i) = \min \left\{ \displaystyle \sum_{(u, v) \in E[G_{T_i}]} d(u, v) \left |
    \begin{array}{l} \label{ST_def}
        T_i \subseteq X_1 \cup X_2 \cup,  \dots \cup X_i\\
        G_{T_i} \text{は$r$を根とする$G_i$上の有向木}\\
        V[G_{T_i}] = T_i,  E[G_{T_i}] \subseteq E[G_i]\\
        A_i \subseteq T_i, B_i \cap T_i = \varnothing \\
        ^{\forall}t \in R \cap G_i \text{に対し，} t \in T_i
    \end{array}
    \right. \right\}.
\end{equation}

各$i$において，$\mathsf{ST}(i; A_i, B_i)$の総重みをもち，上記の条件を満たす有向木$G_{T_i}$が存在する場合，その有向木を$G^{opt}_{T(i, A_i, B_i)}$と表す．このとき，$G^{opt}_{T(s, \varnothing, \varnothing)}$はサイズが最小のDST (minimum-DST)である．


以下で$\mathsf{ST}$の計算式を与える．各$X_i$がintroduceかforgetかで場合分けをして計算する．ただし入力されるグラフがDAGであるため，nice DAGパス分解においてintroduceされる強連結成分はただ一つの頂点からなることに注意する．
%
\begin{align}
    \intertext{$\bullet$ $X_i$が$v \in V$をintroduceしているとき}
    &\mathsf{ST}(i; A_i, B_i) = \label{ST_intro}
    \begin{cases}
        \mathsf{ST}(i-1; A_i \backslash \{v\}, B_i)+ \displaystyle \min_{w \in \mathsf{pred}(v) \cap A_i} d(w, v) &(v \in A_i \text{かつ} \mathsf{pred}(v) \cap A_i \neq \varnothing) \\
        \mathsf{ST}(i-1; A_i, B_i \backslash \{v\})   &(v \in B_i \text{かつ} v \notin R \cup \{r\}) \\
        \infty                      &(otherwise)\\
    \end{cases}.
    \intertext{$\bullet$ $X_i$が$v \in V$をforgetしているとき}
    &\mathsf{ST}(i; A_i, B_i) = \min \{\mathsf{ST}(i-1; A_i \cup \{v\}, B_i), \mathsf{ST}(i-1; A_i, B_i \cup \{v\})\}.\label{ST_forget}
\end{align}


    



DAG $G$のnice DAGパス分解$P$，根$r$，ターミナル$R$が与えられたとき，$\mathsf{ST}$を用いて$R$を含む$G$のminimum-DSTの総重みを出力するアルゴリズム$\mathsf{Compute}(P, r, R)$を示す．


\begin{enumerate}
    \item Preprocessing: $G$において，$r$から到達可能な頂点集合を$V_r$とする．$P$の各バッグ$X_i$に対し，任意の$v \in V \backslash V_r$を$X_i$から取り除く．こうしてできる頂点集合の列をnice DAGパス分解に変換したものを，便宜上新たに$P' = (X_1, X_2, \dots , X_{s'})$とする．
    \item First Step: $\mathsf{ST}(1; \{r\}, \varnothing) = 0$とする．
    \item Exection Step: $P'$の各$X_i$ $(i=2, 3, \dots, s')$に対し，$A_i, B_i$全ての組み合わせについて順に$\mathsf{ST}(i; A_i, B_i)$を計算する．
    \item Final Step: $i = s'$ならば，$\mathsf{ST}(s'; \varnothing, \varnothing)$を出力する．
\end{enumerate}

To demonstrate Theorem~\ref{theorem_DST}, it is sufficient to prove the following two Lemmas.

\begin{lemma}\label{dst}
    $\mathsf{Compute}$は$r$を根とし，$R$をすべて含むような$G$のminimum-DSTの総重みを出力する
\end{lemma}

\begin{proof}
    まず，Preprocessingを行っても解が変わらないことを示す．Preprocessingにおける$V_r$は根$r$から到達可能な頂点の集合であるため，任意の$v \in V \backslash V_r$は目的のminimum-DSTに含まれない．したがって考えるグラフを$G' = G[V \backslash V_r]$としても解は変わらず，また$P'$は$G'$のnice DAGパス分解となっていることに注意すると，$\mathsf{ST}$に入力するnice DAGパス分解を$P'$としても解は変わらない．また$P'$の幅は$P$の幅より大きくならないことに注意する．

    次に，Preprocessing後の処理で$\mathsf{Compute}$が$R$をすべて含むような$G$のminimum-DSTを出力することを示す．これは各$i$について，式(\ref{ST_intro})(\ref{ST_forget})が式(\ref{ST_def})を表していることを示せば十分．これを$i \geq 1$に関する数学的帰納法で示す．    
 
    
    $i=1$のとき，$\mathsf{ST}(1; \{r\}, \varnothing) = 0$は明らかに式(\ref{ST_def})を表す．
    
    $i=k$ $(1 \leq k < s')$のとき，式(\ref{ST_intro})(\ref{ST_forget})が式(\ref{ST_def})を表していると仮定する．以下で$i = k+1$についても式(\ref{ST_intro})(\ref{ST_forget})が式(\ref{ST_def})を表すことを示す．これを$X_{k+1}$が，ある$v \in V$をintroduceするかforgetするかで場合分けして考える．

    
    \begin{itemize}
        \item $X_{k+1}$が$v \in V$をintroduceする場合 \\
        $v \in A_{k+1}, v \in B_{k+1}$に場合分けして考える．
        $v \in A_{k+1}$の場合，$\mathsf{pred}(v) \cap A_{k+1} = \varnothing$ならば，$A_i$において$v$の先行頂点は1つも存在しない．このとき，DAGパス分解のルール2より$v$の先行頂点は$X_{k+1}$以降でintroduceされないため，$v$を含む有向木は$v$が根の一つになっている．これは$r$をただ一つの根とする有向木になり得ないため，$\mathsf{ST}(k+1; A_{k+1}, B_{k+1}) = \infty$とすることで式(\ref{ST_def})で表される有向木$G^{opt}_{T(k, A_{k+1}, B_{k+1})}$が存在しないことを示している．一方，$\mathsf{pred}(v) \cap A_{k+1} \neq \varnothing$ならば，$v$の先行頂点$w \in A_{k+1} \backslash \{v\}$が少なくとも1つ存在する．$i=k$において式(\ref{ST_def})のような有向木 $G^{opt}_{T(k, A_{k+1} \backslash \{v\}, B_{k+1})}$が存在する場合，$w \in G^{opt}_{T(k,A_{k+1} \backslash \{v\}, B_{k+1})}$であるが，Preprocessingの操作より$w$は$r$から到達可能である．したがって$v$もまた$r$から$w$を通過して到達可能であり，$G^{opt}_{T(k, A_{k+1} \backslash \{v\}, B_{k+1}) \cup \{v\}}$は$r$を根とする有向木である．またそのときの最小の総重みは$ \sum_{(u, v) \in E[G^{opt}_{T(k, A_{k+1} \backslash \{v\}, B_{k+1})}]} d(u, v) + \displaystyle \min_{w \in \mathsf{pred}(v) \cap A_i} d(w, v)$と等しい．仮定より$\mathsf{ST}(k; A_k, B_k) =  \sum_{(u, v) \in E[G^{opt}_{T(k, A_k, B_k)}]} d(u, v)$であり，また$A_{k+1} \backslash \{v\} = A_k, B_{k+1} = B_k$に注意すると，$\mathsf{ST}(k+1; A_{k+1}, B_{k+1})$は式(\ref{ST_def})を表す．

        次に$v \in B_{k+1}$の場合を考える．$v \in R \cup \{r\}$のとき$\mathsf{ST}(k+1; A_{k+1}, B_{k+1}) = \infty$であるが，これは式(\ref{ST_def})を表すような有向木$G^{opt}_{T(k, A_{k+1}, B_{k+1})}$が存在しないことを示している．$v \notin R \cup \{r\}$ならば．式(\ref{ST_def})より$v$は解となる有向木に含まれない．このとき$G^{opt}_{T(k+1, A_{k+1}, B_{k+1} \backslash \{v\})} = G^{opt}_{T(k, A_k, B_k)}$が成り立つ．仮定より$\mathsf{ST}(k; A_k, B_k) = \sum_{(u, v) \in E[G^{opt}_{T(k, A_k, B_k)}]} d(u, v)$であり，また$A_{k+1} = A_k, B_{k+1} \backslash \{v\} = B_k$に注意すると，$\mathsf{ST}(k+1; A_{k+1}, B_{k+1})$は式(\ref{ST_def})を表す．
        
        \item $X_{k+1}$が$v \in V$をforgetする場合 \\
        $G_{k+1} = G_k$より，$G^{opt}_{T(k+1, A_{k+1}, B_{k+1})}$は$G_{T_A} = G^{opt}_{T(k, A_k, B_k)}$ $(v \in A_k)$，$G_{T_B} = G^{opt}_{T(k, A_k, B_k)}$ $(v \in B)$のうち，総重みの小さい方と等しい．仮定より$v \in A_k$ならば$\mathsf{ST}(k; A_k, B_k) = \sum_{(u, v) \in E[G^{opt}_{T_A}}$であり，また$v \in B_k$ならば$\mathsf{ST}(k; A_k, B_k) = \sum_{(u, v) \in E[G^{opt}_{T_B}}$である．さらに$v \in A_k$ならば$A_{k+1} \cup \{v\} = A_k, B_{k+1} = B_k$，$v \in B_k$ならば$A_{k+1} = A_k, B_{k+1} \cup \{v\} = B_k$であることに注意すると，$\mathsf{ST}(k+1; A_{k+1}, B_{k+1})$は式(\ref{ST_def})を表す．
    \end{itemize}
    以上より，$i = k+1$でも式(\ref{ST_intro})(\ref{ST_forget})が式(\ref{ST_def})を表している．数学的帰納法によりLemma~\ref{dst}が証明された．
\end{proof}


\begin{lemma}
    DAG $G = (V, E)$の頂点数が$n$であるとする．このとき，幅が$w$である$G$のDAGパス分解$P$，根$r \in V$，$R \subseteq V$が与えられたとき，$k = |R|$とすると，$\mathsf{Compute}(P, r, R)$は$O(2^w(k+w)n + n^2)$の計算時間で最適解を出力する．
\end{lemma}

\begin{proof}
    Preprocessingにおいて，$r$から到達可能な頂点集合の計算に$O(n^2)$かかる．First Step, Final Stepは各々O(1)で計算できる．以下でExection Stepでの計算量を考える．各$X_i$に対し，$|X_i| \leq w + 1$に注意すると，$A_i, B_i$の組み合わせは高々$2^{w+1}$通り存在する．またProposition~\ref{number_of_bag}より$0 \leq i \leq 2|V|+1$である．さらに$X_i$で$v \in V$をintroduceするとき，$\mathsf{pred}(v) \cap A_i \neq \varnothing, \min$ の計算，$v \in R \cup {r}$の判定がそれぞれ高々$O(w), O(w), O(k)$かかることに注意すると，$\mathsf{ST}(i; A_i, B_i)$の計算量は，$X_i$がintroduceならば$O(k+w)$であり，forgetならば$O(1)$である．よってExection Stepでの計算量は$O(2^w(k+w)n)$である．以上より，$\mathsf{Compute}$の計算量は$O(2^w(k+w)n + n^2)$である．
\end{proof}

さらに，上記のアルゴリズムの簡単な拡張により，頂点重み付き有向シュタイナー木問題を効率的に解くことができる．

\begin{theorem}
    頂点重み付きDAG $G$に対し，ターミナルのサイズ$k=|R|$，幅が$w$である$G$のnice DAGパス分解が与えられたとき，$G$のvertex-weighted DST problemを$O(2^w(k+w)n + n^2)$で解くFPTアルゴリズムが存在する．
\end{theorem}